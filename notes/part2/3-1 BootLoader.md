# BootLoader
本章主要复习汇编语言。以下内容整理自网络与我的汇编语言课程笔记

[boot.asm](../../source/3-1/boot.asm)

Boot程序运行时，BIOS会初始化寄存器：CS=0x0000, IP=0x7c00

汇编代码中，一行就是一条代码段指令，大小是一字节

## Intel ASM 伪指令
|   指令    |                           作用                            |                      示例                       |
|:-------:|:-------------------------------------------------------:|:---------------------------------------------:|
|  `org`  |              Origin 指明程序的起始地址，不写的话就是0x0000              |                  org 0x7c00                   |
|  `equ`  |              等价。将左边的式子等价位右面的值，一般用来定义常亮和助记符              |            BaseOfStack equ 0x7c00             |
|  `db`   | 定义变量为字节。在当前行所在的代码段位置开始放置 db 后的内容，如果前面有别名（flag）则可以通过别名访问 |       StartBootMessage: db "Start Boot" ( db "abc" = db 'a', 'b', 'c' )       |
|  `dw`   |                         定义变量为字                          |                                               |
|  `dd`   |                         定义变量为双字                         |                                               |
|  `dq`   |                         定义变量为四字                         |                                               |
|  `dt`   |                         定义变量为十字                         |                                               |
|   `$`   |                     当前行行号（代码段内的偏移量）                     |                                               |
|  `$$`   |                         当前段的首地址                         |                                               |
| `times` |                       重复若干次后面的内容                        | times	510 - ($ - $$)	db	0 ; 代码段中当前指令往后到510填充0 |

### 标号（Label）
标号分为带冒号的和不带冒号的。如下：
```
StartBootMessage:   db  "Hello World"
BS_VolLab	        db	'boot loader'
```
其区别在于，带冒号的使用时编译器只知道位置，不带冒号的使用时编译器同时知道类型（后面的db）

## 寄存器
>部分摘抄自 [这篇博客](https://blog.csdn.net/u014287775/article/details/76572496)

`AX`――累加器（Accumulator），使用频度最高

`BX`――基址寄存器（Base Register），常存放存储器地址

`CX`――计数器（Count Register），常作为计数器

`DX`――数据寄存器（Data Register），存放数据

`SI`――源变址寄存器（Source Index），常保存存储单元地址

`DI`――目的变址寄存器（Destination Index），常保存存储单元地址

`BP`――基址指针寄存器（Base Pointer），表示堆栈区域中的基地址，一般在函数中用来保存进入函数时的sp的栈顶基址，函数开始push，最后pop
> BP默认是SS，在程序运行中用于存放临时的栈基址。比如CALL函数时，MOV BP SP，这样BP临时保存栈底部，通过\[BP+offset\]用于访问传的参数

`SP`――堆栈指针寄存器（Stack Pointer），指示堆栈区域的栈顶地址

[SS, SP, BP 三个寄存器](https://blog.csdn.net/bagboy_taobao_com/article/details/7370504)

`IP`――指令指针寄存器（Instruction Pointer），指示要执行指令所在存储单元的地址。IP寄存器是一个专用寄存器。

`DS`――数据段寄存器，数据段基址

`CS`――代码段寄存器，代码段基址

`SS`――堆栈段寄存器，堆栈段基址

`ES`――附加段寄存器

最早8位机只有a，b等寄存器。

到16位机a，b扩展到16位以后，就把16位叫ax，bx。 高8位叫ah，bh，低8位叫al，bl，其实还是a，b。

到了32位机a，b扩展到32位，又改成eax，ebx。

当然ax，bx继续代表低16位，ah，al，bh，bl，a，b继续维持以前的意义不变。

### MOV的规则
1. CS、IP的值不可以作为目标操作数；
2. dest、src不可以同时作为存储器操作数出现；
3. 段寄存器不能相互转送；
4. 不能把立即数送入段寄存器。

## JMP指令
+ `jmp short ptr` 在当前扇区内跳转，编译成`JMP IP_OFFSET` JMP + 目标位置和现在IP的偏移量，IP修改范围：-128~127，所以是两字节
+ `jmp near  ptr` 在当前CS段内跳转，(IP) = (IP)+16位位移，编译成`JMP TARGET_IP`，所以是 1 + IP宽度 = 1 + 寄存器位宽  字节
+ `jmp far   ptr` 跳转到当前段外，编译为标号对应的`CS:IP`，直接覆盖现在的`CS:IP`，所以是 1 + IP宽度 + CS宽度 = 1 + 2×寄存器位宽 字节

## 运算指令
### DIV
div是除法指令，使用div做除法的时候应注意以下问题：

1、除数：有8位和16位两种，在一个寄存器或者内存中。

2、被除数：默认放在AX或（DX和AX）中，如果除数为8位，被除数为16位，被除数默认在AX中存放，如果除数为16位，被除数为32位，被  除数则在（DX和AX）中存放，DX存放高16位，AX存放低16位。

3、结果：如果除数是8位，则AL存储除法操作的商，AH存储除法操作的余数；如果除数是16位，则AX存储除法操作的商，DX存储除法操作的余数。

格式如下：

div reg

div 内存单元

以100001/100为例，100001大于65535，所以只能用dx和ax两个寄存器联合存放100001，也就是说要进行16位的除法。除数100小于255，可以在一个8位的寄存器中存放，但是被除数是32位的，除数应为16位，所以要使用一个16位的寄存器来存放除数100.

dx和ax分别存放100001的高16位和低16位值，所以将100001表示为16进制的形式：186a1h.

### CMP
CMP a, b

相当于减法，不保存结果，只影响标志位：
+ 结果为零：仅ZF=1
+ 结果为正：仅PF=1
+ 结果为负：仅SF=1，CF=1

## 字符串指令
LODSB / LODSW / LODSD / LODSQ

从`DS:(R|E)SI`指向的内存空间读取 字节(8)、字(16)、双字(32)、四字(64)

保存到`AL / AX / EAX / RAX`之后`SI`根据`DF`自动增加或减少相应位的值。0=增加，1=减少。

## BIOS中断服务程序
调用时中断服务，需要向`AH`传入主功能编号，再向其他寄存器传入参数

`INT 10h` 屏幕相关中断服务 详解在书本 **P34**

`INT 13h` 磁盘相关中断服务
+ 00h 重置驱动器，将磁头移动到默认位置 **P35**
+ 13h 软盘扇区读取，读取成功CF=0，否则CF=1，参数在 **P46**

## FAT12 文件系统
P41 ~ 43

boot程序在引导扇区

物理地址映射：Base << 4 + Offset

各种扇区的相关计算在 **P45**

## 使用nasm编译汇编代码
```shell script
nasm <asm file> -o <object file>
nasm boot.asm -o boot.bin
```

## 在bochs中运行Boot程序
```shell script
# 将编译好的boot程序写入软盘镜像
dd if=boot.bin of=../../resources/boot.img bs=512 count=1 conv=notrunc
# 启动bochs虚拟机
bochs -f resources/bochsrc
```